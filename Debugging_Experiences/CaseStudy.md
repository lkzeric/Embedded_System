# Case Study
# 1. Unexpected Variable Underflow
- Fail Scene: 
    1. FW was stuck in the FTL flow
- Debug Step: 
    1. Since the failure scenario is difficult to reproduce, I chose to review the firmware event log, which records historical variables and firmware behavior. 
    2. After identifying the suspected line, I proceeded to analyze its corresponding assembly code.
- Root Cause
    1. There was a condition intended to check whether the variable ring back to a specific value. However, the expression was not precise enough to properly handle the scenario.
    2. In the following example, (Num-1) would be 0xFFFF_FFFF instead of 0xFF if U8 Num=0. Hence, the unexpected behavior would happen if Num=0. 
        - e.g., if( (Num-1) == MAX_NUM),  where Num is a U8 variable, MAX_NUM = 0xFF definition  
    3. After analyzing the assembly code of the above expression, it appears that this could lead to unexpected behavior.
    4. The firmware developer cannot determine the exact behavior of the assembly code, as it is generated by the compiler.

- Solution:
    1. Write the C code explicitly to avoid any potential misinterpretation by the compiler. 
    2. Modify that expression in a more explicit way. 
        - e.g., if( (Num-1) & 0xFF == MAX_NUM),  where Num is U8 variable, MAX_NUM = 0xFF definition.


# 2. Unexpected Performance Speed Drop
- Fail Scene: 
    1. There was a speed drop by 100MB/s for the R/W performance of the SSD
- Debug Step:
    1. After including one commit which is modified for the case of low power mode, the speed of SSD was decreased by 100MB/s. However, in my expectation, firmware is not in low power mode when conducting the R/W speed test, so it won't be affected by that code change.
    2. Compare the assembly code between the code with the change and that without the change.
- Root Cause:
    1. After applying the change for low power mode, it did affect the assembly code of how to store the function's arguments. 
    2. In the following example, it shows a simple illustration: <br>
       void ParentFunction (U8 A, U8 B, U8 C){<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;if(NormalPowerMode){<br>
       &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// executing under speed test<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;else if(low power mode){<br>
       &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// less likely to execute under speed test<br>
       &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this change also add other local variables in ParentFunction()<br>
       &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}<br>
        }<br>
    3. The change for low power mode affects how the ParentFunction() stored the augument. In the earlier version, all the arguments(U8 A, U8 B, U8 C) are stored in ARM core registers. However, after the modification, some of the arguments are placed in the stack area, since the number of variable is too many to store in the ARM core registers at the same time. Whenever executing the ParentFunction(), the arguments have to be popped from the stack area, so the speed would drop since it would induce more overhead.   
    4. If there are too many local variables or arguments within one function, it's not likely to store all arguments into ARM core registers.
       
- Solution: 
    1. To optimize register usage on ARM, remove unused local variables and function arguments. This practice helps ensure more essential data can be stored in the core registers, improving performance.
    2. Since the case of low power mode would not be executed frequently, Unlikely(ARM Instruction) can be used to hint the compiler not to optimize the branch.


# 3. ARM Scatter File
- Fail Scene: 
    1. FW stuck in FW update flow, since the size of input FW.bin was unexpected.
- Debug Step:
    1. Check the build code flow to find where input FW.bin was generated
- Root Cause:
    1. The ARM scatter file determines how memory is allocated to specific memory regions, such as ATCM and BTCM.
    2. An incorrect modification to the ARM scatter file resulted in an incorrect ATCM size. Hence, the firmware update flow will intercept this type of invalid firmware to prevent it from being flashed to the controller.
- Solution: 
    1. Fix the ARM scatter file

# 4. Clock Uncoherency
- Fail Scene: 
    1. After flashing the firmware to the SSD controller, the controller gets stuck on the first power-on.
- Debug Step:
    1. Since the hang-up occurred so early that the UART hardware had not yet been initialized, no debug information could be printed to clarify the failure.
    2. Load the .axf file onto the target CPU to debug from main() using a JTAG debugger
    3. After the CPU set to the first line of main(), single-stepping could be used to locate fail point 
- Root Cause:
    1. The fail point was the first commands that controller send to Nand Flash directly
    2. The clock of the controller was not synchronized with the NAND Flash clock, which resulted in the commands being misinterpreted.
- Solution: 
    1. Confirm that the clock speeds of the controller and NAND Flash have been set correctly.


# 2. Data Misalignment I
- Fail Scene:
    1. The variable wasn't prorgrammed properly
- Debug Step:
    1. Add the debug info to check if variables are handle correctly
    2. Check the attribute of the memory address
- Root Cause:
    1. In order to accerlate the execution speed, that variable is stored in D-Cache instead of the system buffer (peripheral memory). The CPU can handle data in D-Cache with extremely low latency.
    2. When using HW_API to program variable into Nand Flash, it would only refer to the data in system buffer. In terms of HW_API, it's not able to see the data stored in D-Cache
- Solution: 
    1. Once the variable's value is finalized, the data must be flushed from D-Cache to system buffer. This ensures HW_API can access the correct data in system buffer.

   
# 5. CPU Abort Caused by unexpectedly Overwritting Stack Area
- Fail Scene: 
    1. During execution of seemingly normal code, unexpected CPU abort happened.
- Debug Step:
    1. Set the breakpoint before the line where CPU abort happened
    2. Execute single-stepping with the JTAG debugger to locate the fail point
- Root Cause:
    1. There's a local pointer that points to the variable stored in stack, and it's being used as an array.
    2. This pointer was unexpectedly assigned too many elements, exceeding the array's size
    3. The excessive elements overwrite the data originally stored on the stack. If the data being overwritten won't be used anymore, there's no issue with it. However, in this case, it coincidentally overwrote the value of the return address, which caused the program counter to fail to retrieve the correct return address.
- Solution: 
    1. Be aware the usage of pointer. Have to check if it overwrites other data on stack.
    2. If the pointer must be used, add an assert statement to validate its state and prevent unexpected behavior at runtime.


# 6. Data Misalignment after Power Cycle
- Fail Scene:
    1. After power on, one date structure is loaded from Nand Flash. However, this variable appeared to be incorrect.
- Debug Step:
    1. To solve this kind of problem, it's important to clearly understand the life cycle of this variable.
    2. After checking if the variable is modified during runtime and the point where it is saved/load, there's no unexpected operation.
    3. However, it's appeared that the variable is saved by HW_API and the version of variable is unexpected.
   
- Root Cause:
    1. In the following example, it shows a simple illustration: <br>
    void Function(){<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;DataStucture* A = MEM_ADDR<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;ProgramFlash_HW_API(A);<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;// even though FW executing the next line of ProgramFlash_HW_API(A), it's likely that DataStucture* A has not be programmed into Nand Flash yet<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;// hence, the data is unstable during the period of executing ProgramFlash_HW_API(A) and the data is completely programmed into flash <br> 
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;}<br>
    2. The DataStucture* A is programmed by HW_API, but it doesn't guarantee that HW has finished programming DataStucture* A into Nand Flash after FW executing ProgramFlash_HW_API(A).
    3. Hence, if the value on MEM_ADDR(where DataStucture* A placed) was modified before it's completely programmed, the value save into Nand Flash would be unexpected.
- Solution: 
    1. Add the barrier to ensure HW finished programming.
    2. Copy DataStucture* A to a memory address which will not be modified.